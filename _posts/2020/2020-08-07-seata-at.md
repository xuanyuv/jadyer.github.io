---
layout: post
title: "分布式事务02之Seata-AT模式"
categories: 分布式
tags: 分布式
author: 玄玉
excerpt: 介绍分布式事务框架Seata中的AT模式的原理。
published: true
---

* content
{:toc}


## 简述

它一种无侵入的分布式事务解决方案，属于 2PC 的广义实现，其源自阿里云 GTS 的 AT 模式的开源版

其核心价值在于

* 低成本：编程模型不变（原来怎么写还怎么写），轻依赖，不需要为分布式事务场景做特定设计（没有各种补偿）
* 高性能：一阶段提交（本地提交，全局没提交），不阻塞，连接释放，保证整个系统的吞吐<br>
　　　　　　注：这是比较难的地方，要想保证隔离性，就不能本地提交，这样性能就有衰减<br>
　　　　　　　　虽然 XA 能保证隔离性，但是在没提交的情况下，资源都是被它锁住的，自然性能就不行
* 高可用：极端的异常情况下，可以暂停或跳过异常事务，保证系统可用<br>
　　　　　　注：这就是一个柔性的问题了。比如说微服务设计时，也讲柔性，叫柔性可用<br>
　　　　　　　　最常见的例子就是熔断降级，很多请求实在处理不了了，可以把它丢弃掉，要保证系统的整体可用

## 核心设计

* 一阶段：
1. 拦截业务SQL（可以认为RM把DataSource封装起来了）
2. 生成前镜像（然后再去执行SQL：相当于先备份数据，再执行SQL）
3. 生成后镜像（执行完SQL之后，再备份一下数据，因为分支事务SQL执行完是会本地提交的）
* 二阶段：TC 向所有 RM 发起提交或回滚

如果没有前镜像，那后面回滚时，就需要业务来做补偿，就做不到无侵入了

并且有了补偿就一定要考虑补偿的幂等（并且不是所有的业务都支持补偿时候的幂等），还有空补偿、资源悬挂等等问题

### AT执行阶段

1. 解析SQL：就是看它的影响范围
2. 记录前镜像：比如SQL是 update * where，那记录时把 UPDATE 改成 SELECT 就得到了前镜像的结果集
3. 执行业务SQL
4. 记录后镜像：同样，再 SELECT 一下记录起来
5. 记录undolog：undolog 在 mysql 里面是用来做回滚的，这里就相当于把前后镜像组合在一起记录 undolog
6. 向TC注册分支
7. 提交本地事务
8. 上报本地事务状态给TC

### AT完成阶段（提交）

主要目的是清理快照数据

1. TM向TC发起全局提交
2. TC向RM发起提交（传递XID）
3. RM删除undolog
4. RM返回结果给TC

### AT完成阶段（回滚）

1. 校验脏写：后镜像 VS 当前数据库数据，TC调度某个分支事务去回滚（Rollback XID），该分支会先查undolog，然后校验数据
2. 还原数据：根据前后镜像，生成逆向SQL并“回滚”（其实就是重新写入一次）
3. 删除中间数据：即前后镜像（undolog），最后提交本地事务

## 镜像及行锁举例

以用户下单减商品库存为例（商品编号gid=100，库存数count=10）

现在要减一个库存，即：UPDATE goods SET count=count-1 WHERE gid=100;

1. 首先拦截SQL：SELECT * FROM goods WHERE gid=100，这样得到的就是前镜像（此时count=10）
2. 然后真正去执行减库存的 UPDATE 语句
3. 接着再获取后镜像（同样是上面的 SELECT 语句，此时count=9）
4. 生成undolog（实际就是将前后镜像组合，然后用一个 json 存起来）

用户下单减库存时，每次下单操作都是一个独立的分布式事务，各自有不同的 XID

此时隔离性是能够保证的（即其它 XID 是不会染指到这条数据的），因为每个 XID 都会把 “行锁” （也叫全局锁）注册到 TC 里面

注意这里加了引号，它并不是数据库的那个行锁，可理解成是把主键 gid 的某个值注册到 TC，它是全局的

这是 Seata 自己实现的，保证了先拿到全局锁的全局事务全都做完了事之后，其它全局事务才能提交本地事务

同样，高并发下它也不会出现死锁，只是会有等待，性能有点衰减

**那么新的问题来了：商品增加库存时，它不是一个分布式事务。既然没有分布式事务去管理它，那行锁就锁不住**

于是 AT 模式还支持管理这种单次操作，也就是加一个注解，让它也注册到 AT（虽然它不是分布式事务，但这样可以使用里面的锁）

所以它在操作库存时，也会到 TC 里找所要操作的记录是否被锁住，这就搞定了隔离性

不会出现下单操作还没回滚呢，库存就被修改了，这就保证了不会脏写

但它有个前提：如果不检查（比如某业务未注册到 TC 或人为修改了数据库）全局锁（注册到 TC 上的锁），那锁就失效了没意义了

## Seata隔离性

先列一下四种隔离级别：

* Read Uncommitted（读未提交）：最低隔离级别，会读取到其他事务未提交的数据<br>
　　即其他事务update操作commit之前，它就能读到update之后的结果，若最后update回滚了，那它又读到之前的结果
* Read Committed（读已提交）：事务过程中可以读取到其他事务已提交的数据<br>
　　这是Oracle默认的隔离界别，即只要其他事务还没commit，那读到的都是之前的结果，只有commit后读到的才会是update的结果
* Repeatable Read（可重复读）：每次读取相同结果集，不管其他事务是否提交<br>
　　这是MySQL默认的隔离级别，是依赖MVCC（Multi-Version Concurrent Control，多版本并发控制）实现的快照读<br>
　　比如MySQL中修改了一条记录，它会在记录中加两个列（版本号和回滚指针），回滚指针指向的是undolog中的上一次修改的那条记录<br>
　　上一次的记录里面可能又有回滚指针指向再上一次的修改记录，故无论修改多少次，都能从undolog中读到当时select那一次的数据
* Serializable（可串行化）：事务排队，隔离级别最高，性能最差，也是最严格的隔离级别

### 写隔离

它规定分支事务提交前，需要能拿到全局锁

举例：俩人都要购买 gid=100，那么这俩全局事务都会先去获取本地锁（gid=100，其实就是数据库的锁），先拿到者先减库存

减完库存就需要提交本地事务，这时就要去拿全局锁（就是为了保证只有他一个全局事务在操作 gid=100），拿到之后提交本地事务

接着等待购买的另一个人才会拿到他的本地锁，去减库存，去提交本地事务（这时继续去拿全局锁）

如果拿全局锁超时，那就回滚本地事务，释放本地锁

### 读隔离

1. 如果什么都不做，那么默认全局事务的隔离级别是读未提交
2. 如果全局事务也想做到可重复读，至少要保存近期的undolog，不能用完一个删一个，期待后面会有这个功能
3. 如果全局事务也想做到读已提交，那就用SELECT FOR UPDATE来拿全局锁（Seata检测到这个后缀，就会检测资源，进行全局锁判断，如果有事务资源锁定就等待全局锁释放），这就实现了

## AT存在的问题

* 重量级SDK
* 依赖数据库本地事务的 ACID 特性
* 如果用的是mongodb或其他的KV存储，AT 搞不定，所以 Seata 又搞了TCC、Saga

虽然 Saga 是不加锁的，直接事务提交就提交了，也没有全局锁控制，所以其性能衰减比较弱，但是业务侵入大