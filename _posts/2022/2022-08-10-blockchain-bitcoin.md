---
layout: post
title: "区块链的架构与比特币应用"
categories: 分布式
tags: 分布式
author: 玄玉
excerpt: 介绍区块链的架构原理与比特币的用法。
published: true
---

* content
{:toc}


## 高可用与多写

普通的存储系统（如MySQL），通常要解决 2 个的问题：非高可用、单点写入

### 高可用

**高可用的方法论，其实就两个字：冗余。**

即把数据复制几份，冗余到多个地方，就能保证高可用（MySQL的主从集群、磁盘的RAID等就是这个原理）

但数据冗余往往会有 2 个副作用：

* 数据一致性：例如MySQL主从集群，读写会有延时，即会有一个短时间内的读写不一致
* 写入的效率：数据冗余往往会降低写入的效率，因为数据同步也是需要消耗资源的

**注意：分库分表解决的不是高可用的问题，它解决的是数据量大的问题**

### 多写

普通的存储系统，也可以多点写入，但多写可能引发数据一致性的问题：即写写冲突

例如 MySQL 也可以做一个双主的主从同步：两个节点可以同时写入

假设某表的主键是自增ID，目前 2 个主节点中的表数据都是 id=1/2/3/4，然后 A 节点写入了一条数据，此时 A.id=5

在 A.id=5 的数据同步到 B 节点的过程中，B 也写入了一条数据，B.id 也会变成 5，于是 B 也向 A 同步数据

当同步数据到达对方后，冲突了，于是同步失败，这就是写写的一致性冲突问题

避免方式就是：不依赖于数据库层面的自增ID，而是由应用层来生成这个ID（简单的场景也可以用不同步长的方法）

> MySQL的众多HA方案中，有一种MMM(Multi Master Replication Manager)架构与之类似<br/>
大致思路就是：同样有 2 个主节点，但只有一个对外提供服务，另外一个stand by（且二者在实时的双主同步）<br/>
同时，两个主节点使用相同的虚IP（即内网IP是相同的），然后通过类似于Keepalived的方式去探活<br/>
当发现主库有问题的时候，就将流量打到另外一个主库上，整个过程对于应用层是透明的

当写写发生了一致性冲突时，常见的处理方式有以下 3 种：

* 投票：集群中的多个节点来投票，以多数票的数据为准
* 时间戳：以时间戳最小的数据为准，即最早写入的那一条为准，后写入的放弃<br/>
　　　　但时间戳也要注意时钟同步的问题（毕竟多进程异步系统中，是没有全局绝对时钟的）<br/>
　　　　也有一些时钟同步的算法，比如这篇文章：[巧妙测量服务器之间的时间差](https://cloud.tencent.com/developer/article/1047787)
* ID串行化：多点写入前，去同一个地方领取ID，再各自写入，写入时若发现业务属性冲突，就以最小ID为准<br/>
　　　　　即时通讯中，群消息经常会用到这个，能保证每个人看到的消息序列是相同的<br/>
　　　　　像微信/QQ这种群消息，其实每个人看到的消息序列不同，也没多大问题（技术上可以做到，业务上未必必需）

## 区块链的本质

**区块链是一个去中心化的（没有中心节点和管理员）、每个节点都拥有全部数据的、高可用的、分布式存储系统**

而，区块，就是一块可以存储数据的存储空间

再通过类似链表的方式，将各个区块串联起来，并约定了一系列算法来管理这些数据

这就组成了区块链，所以区块链的本质就是一个多点写入的存储管理系统

所以区块链有两个很大的特点：存储数据少，数据写入慢

### 区块的组成

一个区块，由区块头和区块体组成

* 区块体：存储交易数据
* 区块头：存储区块的元数据，如上一个区块的哈希值，本区块生成时的时间戳和随机数等等

![](https://cdn.jsdelivr.net/gh/jadyer/mydata/img/blog/2022/2022-08-10-blockchain-bitcoin-01.jpg)

如上图所示，区块头存储了上一个区块的哈希值，本区块生成时的时间戳和随机数等等

一个区块，它的唯一标识是这个区块的哈希值（好似链表一样，每个链表节点的唯一标识是它的指针）

于是，通过每个区块的哈希值，将所有的区块链起来（跟链表很像），就组成了区块链

### 区块的特性

1. 历史区块无法改变
2. 只能在最新的区块后面，生成新区块（所以必须同步完全网最新的区块，才能启动生成新区块的工作）
3. 新区块很难生成，必须满足特定条件

## 比特币

比特币就是基于区块链这个分布式存储系统，在其上层实现的一个电子货币的应用

比特币与区块链的关系，就好似微信与 MySQL 的关系（MySQL 做底层存储，微信是 MySQL 上层的应用）

2008 年中本聪在设计比特币网络时，把每个区块的大小限定在了 1 MB

这也就意味着每个区块里能存储的信息最多也只有 1MB（目前比特币的区块链大小已经超过了 300 GB）

并且，它每 10 分钟才生成一个区块，大约能够写入 2000 笔比特币交易的数据

可以大致认为比特币的交易，每 10 分钟只能处理 2000 笔交易

### 挖矿

生成一个区块，并链入区块链的过程，就是挖矿

而挖矿的人，就是矿工

挖到矿（生成新区块）必须满足以下 2 个条件，才算成功：

1. 需要对新生成的区块头，进行 2 次 SHA256
2. 得到的哈希结果，高 48bit 必须是 0x00000000FFFF

由于每一个区块头都记录了前一个区块的哈希值，所以新区块能变的其实只有时间戳和随机数等等

由于哈希是不可逆的，所以也不能通过哈希结果的高48bit是0x00000000FFFF来反向推导出时间戳和随机数

可以认为哈希的结果是完全随机的，**即区块链以及挖矿的一切基础：哈希不可逆性！**

>要得出前48bit是一个给定的bit，就如同连续抛48次硬币，每次得到的都是想要的结果，这个概率非常非常小<br/>
就好比在一座山上随机捡起了一块石头，这块石头又正好是一块金子，概率非常非常小<br/>
可能就是因为这个，才称它为挖矿吧，因为一旦成功生成了一块，就等于是捡到了金子

如果逆推不行，唯一使用的方法，就是正向的穷举法，伪代码如下

```java
byte[32] = PrevBlockHash;                     // 上一个区块的哈希
for(int i=0 to 2^32){                         // 遍历所有整数
    long time = now();                        // 时间戳
    blockHeader = new(byte[32], time, i);     // 生成区块头
    hashResult = SHA256(SHA256(blockHeader)); // 计算哈希值（两次SHA256）
    if(hashResult>>208 == 0x00000000FFFF){    // 哈希符合预期
        echo "bingo";                         // 挖到矿啦
    }
}
```

那么，是不是执行的时间足够久，就一定能挖到矿呢？

并不是！

如果别人的计算能力比你强，在你挖到矿之前，别人先挖到了一个矿，并把他挖到的矿广播到区块链的全链路

此时你本地就不是最新的区块链了，你必须要同步别人先挖到的矿，你才能够在尾部继续挖

所以，你要不断的向网络同步最新的数据，并继续或重新开始挖矿

### 提升挖矿速度

从架构的角度，通常会考虑以下三种方法：

* 缓存：无效（因为每个区块的哈希值、时间戳、随机值都也不一样，所以无法通过查表的方式来节省时间）
* Scale up：有效（即提升单机能力：比如优化程序，增强单 cpu 的计算能力，用 gpu 替代 cpu，用特殊的芯片计算 sha256d）
* Scale out：有效（即水平扩展：一台机器不行，那就搞集群。如果想跟别人拼算力，往往都是通过这种方式提升本地算力）

下图就是西藏高原上的一个比特币矿场，它通过风力和太阳能发电，所以电力比较便宜

所有的矿机都是在进行 sha256 计算，尝试同步全球最新的区块数据，并挖到矿

![](https://cdn.jsdelivr.net/gh/jadyer/mydata/img/blog/2022/2022-08-10-blockchain-bitcoin-02.png)

>提升系统性能，不管是区块链还是做系统架构，无外乎这 2 个方法：scale up、scale out<br/>
一种是提升软件性能，一种是提升硬件性能<br/>
软件：比如发现有一个性能瓶颈，那就优化代码（无锁的方式、并发的方式、巧妙的算法、巧妙的数据结构等）<br/>
硬件：由于单节点的软件性能的优化一定是有上限的，你没办法做到无穷，那么还可以提高单机的硬件性能<br/>
　　　但是，单机硬盘、CPU核数、内存也不可能无限大，所以最终想无限性能，理论上还是 scale out 的方式

### 矿的匀速机制

区块链有个特点：虽然大家都在挖矿，但挖到矿的速度是均匀的

以承载比特币的区块链为例：平均每 10 分钟产出一个区块，这个速度基本上是不变的

即：并不是计算能力越来越强、计算节点越来越多、哈希速度越来越快，产出矿的速度就会越来越快

因为这里面有一套动态调节的匀速机制，来保证生成区块的速度是均匀的

